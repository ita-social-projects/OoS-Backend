# Default values for outofschool.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

global:
  extraEnvironment: {}


# TODO: Configure global pull secrets
imagePullSecrets: []

# TODO: Do we need overrides?
nameOverride: ""
fullnameOverride: ""
# TODO: remove after fixing test connection
service:
  port: 8080

# TODO: Already have a service account for app, do we need a global one?
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

## Nginx ingress default config
ingress-nginx:
  enabled: false
  controller:
    config:
      proxy-body-size: 10m
    service:
      enabled: true
      type: ClusterIP
    metrics:
      enabled: false
      serviceMonitor:
        enabled: false
  defaultBackend:
    enabled: true
    autoscaling:
      enabled: true
      minReplicas: 1
      maxReplicas: 2

# TODO: Think how to make it simpler so it can be moved to Elastic PostStart
# TODO: Obvious fuckup - using toyaml instead of to json in configmap
elasticConfigJob:
  roles:
    outofschool:
      cluster:
        - monitor
      indices:
        - names:
            - workshop
          privileges:
            - read
            - write
            - delete
            - create_index
            - view_index_metadata
            - manage
          allow_restricted_indices: false
      applications:
        - application: kibana-.kibana
          privileges:
            - space_read
          resources:
            - space:default
      metadata:
        version: 2
  secret: elasticsearch-credentials

cert-manager:
  enabled: false
  installCRDs: true
  prometheus:
    enabled: false

elasticsearch:
  enabled: false
  generateCertificate: true
  replicas: 1
  protocol: http
  esConfig:
    elasticsearch.yml: |
      xpack.license.self_generated.type: basic
      xpack.security.enabled: true
      xpack.security.transport.ssl.enabled: true
      xpack.security.transport.ssl.verification_mode: certificate
      xpack.security.transport.ssl.key: /usr/share/elasticsearch/config/certs/tls.key
      xpack.security.transport.ssl.certificate: /usr/share/elasticsearch/config/certs/tls.crt
      xpack.security.transport.ssl.certificate_authorities: /usr/share/elasticsearch/config/certs/ca.crt
      xpack.security.http.ssl.enabled: false
      xpack.security.http.ssl.key: /usr/share/elasticsearch/config/certs/tls.key
      xpack.security.http.ssl.certificate: /usr/share/elasticsearch/config/certs/tls.crt
      xpack.security.http.ssl.certificate_authorities: /usr/share/elasticsearch/config/certs/ca.crt
  #  log4j2.properties: |
  #    key = value
  secretMounts:
    - name: elastic-certificates
      secretName: elastic-certificates
      path: /usr/share/elasticsearch/config/certs
  extraEnvs:
    - name: ELASTIC_PASSWORD
      valueFrom:
        secretKeyRef:
          name: elasticsearch-credentials
          key: password
    - name: ELASTIC_USERNAME
      valueFrom:
        secretKeyRef:
          name: elasticsearch-credentials
          key: username

  # Allows you to load environment variables from kubernetes secret or config map
  envFrom: []
  # - secretRef:
  #     name: env-secret
  # - configMapRef:
  #     name: config-map
  hostAliases: []
  #- ip: "127.0.0.1"
  #  hostnames:
  #  - "foo.local"
  #  - "bar.local"
  esJavaOpts: "-Xms512m -Xmx512m" # example: "-Xmx1g -Xms1g"
  volumeClaimTemplate:
    accessModes: [ "ReadWriteOnce" ]
    storageClassName: "openebs-hostpath"
    resources:
      requests:
        storage: 100M
  extraInitContainers:
  - name: plugins
    image: docker.elastic.co/elasticsearch/elasticsearch:7.15.0
    command: ['/bin/sh', '-c']
    args: ['./bin/elasticsearch-plugin list | grep -q analysis-ukrainian || ./bin/elasticsearch-plugin install analysis-icu analysis-ukrainian mapper-murmur3 mapper-size']

  resources:
    requests:
      cpu: "500m"
      memory: "1Gi"
    limits:
      cpu: "500m"
      memory: "1Gi"
  rbac:
    create: true
  lifecycle: {}
  # preStop:
  #   exec:
  #     command: ["/bin/sh", "-c", "echo Hello from the postStart handler > /usr/share/message"]
  # postStart:
  #   exec:
  #     command:
  #       - bash
  #       - -c
  #       - |
  #         #!/bin/bash
  #         # Add a template to adjust number of shards/replicas
  #         TEMPLATE_NAME=my_template
  #         INDEX_PATTERN="logstash-*"
  #         SHARD_COUNT=8
  #         REPLICA_COUNT=1
  #         ES_URL=http://localhost:9200
  #         while [[ "$(curl -s -o /dev/null -w '%{http_code}\n' $ES_URL)" != "200" ]]; do sleep 1; done
  #         curl -XPUT "$ES_URL/_template/$TEMPLATE_NAME" -H 'Content-Type: application/json' -d'{"index_patterns":['\""$INDEX_PATTERN"\"'],"settings":{"number_of_shards":'$SHARD_COUNT',"number_of_replicas":'$REPLICA_COUNT'}}'
  # TODO: check if need this
  # Disable privileged init Container creation.
  # sysctlInitContainer:
  #   enabled: false
  # TODO: check if need this
  # Restrict the use of the memory-mapping when sysctlInitContainer is disabled.
  # esConfig:
  #   elasticsearch.yml: |
  #     node.store.allow_mmap: false

kibana:
  enabled: false
  resources:
    requests:
      cpu: "500m"
      memory: "1Gi"
    limits:
      cpu: "500m"
      memory: "1Gi"
  extraEnvs:
    - name: 'ELASTICSEARCH_USERNAME'
      valueFrom:
        secretKeyRef:
          name: elasticsearch-credentials
          key: username
    - name: 'ELASTICSEARCH_PASSWORD'
      valueFrom:
        secretKeyRef:
          name: elasticsearch-credentials
          key: password

mysql:
  enabled: false
  architecture: standalone
  rbac:
    create: true
  auth:
    database: outofschool
    username: "oos"
    replicationUser: replicator

    existingSecret: "mysql-auth"
    ## @param auth.forcePassword Force users to specify required passwords
    ##
    forcePassword: false
    usePasswordFiles: false
  initdbScripts:
    my_init_script.sh: |
      #!/bin/bash
      mysql -u root -p${MYSQL_ROOT_PASSWORD} <<EOF
      CREATE USER 'webapi'@'%' IDENTIFIED BY '${API_PASSWORD}';
      GRANT INSERT ON outofschool.* TO 'webapi'@'%';
      GRANT SELECT ON outofschool.* TO 'webapi'@'%';
      GRANT UPDATE ON outofschool.* TO 'webapi'@'%';
      GRANT DELETE ON outofschool.* TO 'webapi'@'%';
      FLUSH PRIVILEGES;
      EOF
  primary:
    persistence:
      enabled: true
      storageClass: openebs-hostpath
      size: 30Gi 
    extraEnvVarsSecret: mysql-api-auth

phpmyadmin:
  enabled: true
  ingress:
    enabled: false
    hostname: phpmyadmin.local
    pathType: ImplementationSpecific
    ## @param ingress.annotations Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
    ## For a full list of possible ingress annotations, please see
    ## ref: https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/annotations.md
    ## Use this parameter to set the required annotations for cert-manager, see
    ## ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
    ##
    ## e.g:
    ## annotations:
    ##   kubernetes.io/ingress.class: nginx
    ##   cert-manager.io/cluster-issuer: cluster-issuer-name
    ##
    annotations:
      kubernetes.io/ingress.class: nginx
    ## @param ingress.tls Enable TLS configuration for the hostname defined at `ingress.hostname` parameter
    ## TLS certificates will be retrieved from a TLS secret with name: {{- printf "%s-tls" .Values.ingress.hostname }}
    ## You can use the ingress.secrets parameter to create this TLS secret, relay on cert-manager to create it, or
    ## let the chart create self-signed certificates for you
    ##
    tls: false
    ## @param ingress.extraHosts The list of additional hostnames to be covered with this ingress record.
    ## Most likely the hostname above will be enough, but in the event more hosts are needed, this is an array
    ## Example:
    ## extraHosts:
    ##   - name: phpmyadmin.local
    ##     path: /
    ##
    extraHosts: []
    ## @param ingress.extraTls The tls configuration for additional hostnames to be covered with this ingress record.
    ## see: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
    ## Example:
    ## extraTls:
    ## - hosts:
    ##     - phpmyadmin.local
    ##   secretName: phpmyadmin.local-tls
    ##
    extraTls: []
    ## @param ingress.secrets If you're providing your own certificates, please use this to add the certificates as secrets
    ## key and certificate should start with -----BEGIN CERTIFICATE----- or -----BEGIN RSA PRIVATE KEY-----
    ## name should line up with a secretName set further up
    ##
    ## If it is not set and you're using cert-manager, this is unneeded, as it will create the secret for you
    ## If it is not set and you're NOT using cert-manager either, self-signed certificates will be created
    ## It is also possible to create and manage the certificates outside of this helm chart
    ## Please see README.md for more information
    ##
    ## Example
    ## secrets:
    ##   - name: phpmyadmin.local-tls
    ##     key: ""
    ##     certificate: ""
    ##
    secrets: []
  db:
    allowArbitraryServer: false
    host: "mysql"

mongodb:
  enabled: false
  architecture: standalone
  useStatefulSet: true
  auth:
    enabled: true
    rootUser: root
    usernames: ["webapi"]
    databases: ["outofschool"]
    ## @param auth.existingSecret Existing secret with MongoDB&reg; credentials (keys: `mongodb-password`, `mongodb-root-password`, ` mongodb-replica-set-key`)
    ## NOTE: When it's set the previous parameters are ignored.
    ##
    existingSecret: "mongodb-credentials"
  ## @param initdbScripts Dictionary of initdb scripts
  ## Specify dictionary of scripts to be run at first boot
  ## Example:
  ## initdbScripts:
  ##   my_init_script.sh: |
  ##      #!/bin/bash
  ##      echo "Do something."
  ##
  initdbScripts: {}
  persistence:
    ## @param persistence.enabled Enable MongoDB&reg; data persistence using PVC
    ##
    enabled: true
    ## @param persistence.existingClaim Provide an existing `PersistentVolumeClaim` (only when `architecture=standalone`)
    ## Requires persistence.enabled: true
    ## If defined, PVC must be created manually before volume will be bound
    ## Ignored when mongodb.architecture=replicaset
    ##
    # existingClaim: ""
    storageClass: "openebs-hostpath"
    size: 10Gi
  metrics:
    enabled: false

webapi:
  enabled: true
  aspNetCoreEnvironment: Release
  image:
    repository: gcr.io/gcp101292-pozashkillya/oos-api
    pullPolicy: IfNotPresent
    tag: 1.0.0-RC1
  extraEnvironment:
    # ReverseProxy__BasePath: /webapi
  connectionString:
    username: webapi
    secret:
      name: mysql-api-auth
      key: API_PASSWORD
identity:
  enabled: true
  aspNetCoreEnvironment: Release
  image:
    repository: gcr.io/gcp101292-pozashkillya/oos-auth
    pullPolicy: IfNotPresent
    tag: 1.0.0-RC1
  extraEnvironment:
    # ReverseProxy__BasePath: /identity
  connectionString:
    username: oos
    secret:
      name: mysql-auth
      key: mysql-password
frontend:
  enabled: false
  image:
    repository: gcr.io/gcp101292-pozashkillya/oos-frontend
    pullPolicy: IfNotPresent
    tag: 1.0.0-RC1